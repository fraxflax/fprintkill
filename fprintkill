#!/bin/sh
#
# fprintkill is a POSIX-compliant (pure bourne shell) script for
# launching an executable and be able to kill it by reading your
# fingerprint.
# 
# This is free software created by frax@axnet.nu,
# feel free to use, modify and/or distribute as you see fit.
# 
fprintkill="`basename "$0" 2>/dev/null`" || fprintkill="fprintkill"
DEPS="fprintd-verify pgrep pkill ps sed setsid" 
USAGE() {
    COLS=72; ___=''; __=''; which tput>/dev/null && { COLS=`tput cols`; ___=`tput bold`; __=`tput sgr0`; }
    FMT=cat;which fmt>/dev/null && FMT="fmt -w $COLS"
    $FMT<<EOU

${___}SYNOPSIS:
	$fprintkill$__ [ cmd [ arg ...] ]

	Executes cmd [ arg ...] and for as long as cmd is running,
	upon successfull fingerprint verify, cmd is terminated.

	The fingerprint termination depends on 'fprintd-verify',
	'pgrep', 'pkill', 'ps', 'sed' and 'setsid'. If they are not
	found, a warning will be printed to stderr but the cmd will
	still be launched, even though it cannot be killed by
	fingerprint. (To satisfy the dependencies in Debian/Ubuntu:
	apt install util-linux procps sed fprintd util-linux).

	If no arguments are given to fprintkill, enviroment variables
	FPK_EXEC and FPK_ARGS are used for cmd [ arg ...]

${___}EXAMPLES:$__
	Lock the screen with slock (if within PATH) terminating it
	upon verified fingerprint:
	   $fprintkill slock

	Run '/usr/bin/xtrlock -b' in the background terminating it
	upon verified fingerprint:
	   $fprintkill /usr/bin/xtrlock -b &

	Alternative using environment variables:
	   env FPK_EXEC=/usr/bin/xtrlock FPK_ARGS=-b $fprintkill &

	Arguments with whitespaces are ok:
	   $fprintkill sh -c "xset dpms force off ; xtrlock" &

	Alternative using environment variables:
	   env FPK_EXEC=sh FPK_ARGS='-c  "xset dpms force off ; xtrlock"' &

	Also daemons are properly handled.  To launch xtrlock in the
	background as a daemon that will be terminated upon verified
	fingerprint:
	   $fprintkill xtrlock -f

	In the case a daemon forks off several parallel processes
	before exiting, all of those will be monitored and terminated
	upon verified fingerprint. Cleanup will not be performed
	before all of the parallell processes have exited or have been
	terminated. In this example, if proc1 exits, fprintkill will
	keep monitoring proc2 and proc3. If proc1, proc2 and proc3 all
	exits fprintkill will clean up. Upon verified fingerprint,
	proc1, proc2 and proc3 (and their child processes, if any)
	will be terminated:
	   $fprintkill sh -c "proc1 & proc2 & proc3 & exit 0"

EOU
    exit 1
}
test -n "$1" && {
    FPK_EXEC="$1"
    FPK_ARGS=
    n=2
    while eval "test -n \"\$$n\""; do
	eval "FPK_ARGS=\"$FPK_ARGS '\$$n'\""
	n=$((n+1))
    done
}
which "$FPK_EXEC">/dev/null 2>&1 || test -x "$FPK_EXEC" || USAGE

# The process id of cmd (once exec)
xpid=$$

# Process group
pgid=`ps -opgid= $xpid` || { echo "ERROR: ps: $!" > /dev/stderr; exit 1 ;}

# Check dependencies for fingerprint killing
lacking=
for x in $DEPS; do which $x>/dev/null || lacking="$lacking $x"; done
if [ -n "$lacking" ]; then
    cat<<EOW>/dev/stderr

WARNING!

The following executables are lacking in your PATH:
 $lacking
preventing fingerprint killing from being performed.

The full depencies (apart from coreutils) for fingerprint kill are:
  $DEPS
(in debian/ubuntu: apt install util-linux procps sed fprintd )

EOW
else
    # Ensure we have a separate process group
    test $xpid -eq $pgid || { setsid --fork $0 "$@"; exit 0; }

    # Fork off two proccesses,
    # the inner: terminating the executable upon verified fingerprint,
    # the outer: killing potentially remaining fprintd-verify processes
    # (if the exec exited by some other mean than after fprintd-verify).

    sleep 1 # allow cmd to launch and possibly become a daemon

    ps -opid= $xpid >/dev/null 2>&1 || { # cmd has exited 
	# get pids daemon forked off processes
	GPIDS=`pgrep -g $pgid`
	cpids=`echo $GPIDS | sed -E 's/[^ ]+ //'` # (first pid is me)
	test "$cpids" = "$GPIDS" || xpid=$cpids
    }
	
    # Fork & do fprintd-verify for as long as executable still alive
    while ps -opid= $xpid >/dev/null; do
	fprintd-verify -f any >/dev/null 2>&1 && {
	    pkill -TERM -g $pgid >/dev/null 2>&1
	    exit 0
	}
    done &
	
    # Check every 10:th second if executable is still alive
    while ps -opid= $xpid >/dev/null; do sleep 10; done 
    
    # Kill potentially remaining children 
    pkill -TERM -g $pgid >/dev/null 2>&1
    exit 0
fi &

eval "exec '$FPK_EXEC' $FPK_ARGS"
