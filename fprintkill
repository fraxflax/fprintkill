#!/bin/sh
#
# fprintkill is a POSIX-compliant (pure bourne shell) script for
# launching an executable and be able to kill it by reading your
# fingerprint.
# 
# This is free software created by frax@axnet.nu,
# feel free to use, modify and/or distribute as you see fit.
# 
fprintkill="`basename "$0" 2>/dev/null`" || fprintkill="fprintkill"
USAGE() {
    COLS=72; ___=''; __=''; which tput>/dev/null && { COLS=`tput cols`; ___=`tput bold`; __=`tput sgr0`; }
    FMT=cat;which fmt>/dev/null && FMT="fmt -w $COLS"
    $FMT<<EOU

${___}SYNOPSIS:
	$fprintkill$__ [ cmd [ arg ...] ]

	Executes cmd [ arg ...] and for as long as cmd is running,
	upon successfull fingerprint verify, cmd is terminated.

	The fingerprint termination depends on 'fprintd-verify',
	'pkill' and 'setsid' (debian: apt install fprintd procps
	util-linux). If they are not found, a warning will be printed
	to stderr but the cmd will still be launched, but cannot be
	killed by fingerprint.

	If no arguments are given to fprintkill, enviroment variables
	FPK_EXEC and FPK_ARGS are used for cmd [ arg ...]

${___}EXAMPLES:$__
	Lock the screen with slock (if within PATH) terminating it
	upon verified fingerprint:
	   $fprintkill slock

	Run '/usr/bin/xtrlock -b' in the background (as if it was run
	by 'xtrlock -f -b') terminating it upon verified fingerprint.
	   $fprintkill /usr/bin/xtrlock -b &

	Alternative way of doing the xtrlock above:
	   env FPK_EXEC=/usr/bin/xtrlock FPK_ARGS=-b $fprintkill &

	fprintkill does handle arguments with whitespaces:
	   $fprintkill sh -c "xset dpms force off ; xtrlock"

	Alternative way:
	   env FPK_EXEC=sh FPK_ARGS='-c "xset dpms force off ; xtrlock"' $fprintkill

EOU
    exit 1
}
test -n "$1" && {
    FPK_EXEC="$1"
    FPK_ARGS=
    n=2
    while eval "test -n \"\$$n\""; do
	eval "FPK_ARGS=\"$FPK_ARGS '\$$n'\""
	n=$((n+1))
    done
}
which "$FPK_EXEC">/dev/null 2>&1 || test -x "$FPK_EXEC" || USAGE

# The process id of cmd (once exec)
xpid=$$

# Process group
pgid=`ps -opgid= $xpid` || { echo "ERROR: ps: $!" > /dev/stderr; exit 1 ;}

# Check dependencies for fingerprint killing
DEPS="setsid ps sed fprintd-verify pgrep pkill"
lacking=
for x in $DEPS; do which $x>/dev/null || lacking="$lacking $x"; done
if [ -n "$lacking" ]; then
    cat<<EOW>/dev/stderr

WARNING!

The following executables are lacking in your PATH:
$lacking
preventing fingerprint killing from being performed.

The full depencies (apart from coreutils) for fingerprint kill are:
$DEPS

(in debian/ubuntu: apt install util-linux procps sed fprintd )

EOW
else
    # Ensure we have a separate process group
    test $xpid -eq $pgid || { setsid --fork $0 "$@"; exit 0; }

    # Fork off two proccesses,
    # the inner: terminating the executable upon verified fingerprint,
    # the outer: killing potentially remaining fprintd-verify processes
    # (if the exec exited by some other mean than after fprintd-verify).

    sleep 1 # allow cmd to launch and possibly become a daemon

    ps -opid= $xpid >/dev/null 2>&1 || { # cmd has exited 
	# get daemon pid if cmd forked
	PIDS=`pgrep -g $pgid`
	pid=`echo $PIDS | sed -E 's/.* //'`
	test "$pid" = "$PIDS" || xpid=$pid
    }
	
    # Fork & do fprintd-verify for as long as executable still alive
    while ps -opid= $xpid >/dev/null; do
	fprintd-verify -f any && {
	    pkill -TERM -g $pgid
	    exit 0
	}
    done &
	
    # Check every 10:th second if executable is still alive
    while ps -opid= $xpid >/dev/null; do sleep 10; done 
    
    # Kill potentially remaining children 
    pkill -TERM -g $pgid
    exit 0
fi &

eval "exec '$FPK_EXEC' $FPK_ARGS"
